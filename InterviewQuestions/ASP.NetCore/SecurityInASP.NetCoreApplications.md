**<u>Improving your application's security:</u>**

****

==**<u>Cross-site scripting (XSS)</u>** attacks involve malicious users injecting content into your app, typically to run malicious JavaScript when users browse your app. You can avoid XSS injection attacks by always encoding unsafe input before writing it to a page. Razor Pages do this automatically== unless you use the @Html.Raw() method, so use it sparingly and carefully.
• ==**<u>Cross-site request forgery (CSRF)</u>** attacks are a problem for apps that use cookie-based authentication, such as ASP.NET Core Identity. It relies on the fact that browsers automatically send cookies to a website. A malicious website could create a form that POSTs to your API, and the browser will send the authentication cookie with the request. This allows malicious websites to send requests as though they’re the loggedin user.
• You can mitigate CSRF attacks using **<u>anti-forgery tokens</u>**. These involve writing a hidden field in every form that contains a random string based on the current user. A similar token is stored in a cookie. A legitimate request will have both parts, but a forged request from a malicious website will only have the cookie half; they cannot recreate the hidden field in the form. By validating these tokens, your API can reject forged requests.
• The Razor Pages framework automatically adds anti-forgery tokens to any forms you create using Razor and validates the tokens for inbound requests.== You can disable the validation check if necessary, using the [IgnoreAntiForgeryToken] attribute. 
• ==Browsers won’t allow websites to make JavaScript AJAX requests from one app to others at different origins. To match the origin, the app must have the same scheme, domain, and port. If you wish to make cross-origin requests like this, you must enable **<u>cross-origin resource sharing (CORS)</u>** in your API.==
• CORS uses HTTP headers to communicate with browsers and defines which origins can call your API. In ASP.NET Core, you can define multiple policies, which can be applied either globally to your whole app, or to specific controllers and actions.
• You can add the CORS middleware by calling UseCors() in Startup.Configure and optionally providing the name of the default CORS policy to apply. You can also apply CORS to a Web API action or controller by adding the [EnableCors] attribute and providing the name of the policy to apply.
• ==**<u>Open redirect attacks</u>** use the common returnURL mechanism after logging in to redirect users to malicious websites. You can prevent this attack by ensuring you only redirect to local URLs, URLs that belong to your app.
• **<u>Insecure direct object references</u>** are a common problem where you expose the ID of database entities in the URL. You should always verify that users have permission to access or change the requested resource by using resource-based authorization in your action methods.
• **<u>SQL injection attacks</u>** are a common attack vector when you build SQL requests manually. Always use parameterized queries when building requests, or instead use a framework like EF Core, which isn’t vulnerable to SQL injection.==
• The most sensitive data in your app is often the data of your users. Mitigate this risk by only storing data that you need. Ensure you only store passwords as a hash, protect against weak or compromised passwords, and provide the option for 2FA. ASP.NET Core Identity provides all of this out of the box, so it’s a great choice if you need to create an identity provider  

**<u>Authentication: Adding users to your application with Identity:</u>**

==Authentication is the process of determining who you are and authorization is the process of determining what you’re allowed to do. You need to authenticate users before you can apply authorization.
• Every request in ASP.NET Core is associated with a user, also known as a principal. By default, without authentication, this is an anonymous user. You can use the claims principal to behave differently depending on who made a request.
• The current principal for a request is exposed on HttpContext.User. You can access this value from your Razor Pages and views to find out properties of the user such as their, ID, Name or Email.
• Every user has a collection of claims. These claims are single pieces of information about the user. Claims could be properties of the physical user, such as Name and Email, or they could be related to things the user has, such as HasAdminAccess or IsVipCustomer.==
• Earlier versions of ASP.NET used roles instead of claims. You can still use roles if you need to, but you should use claims where possible.
• ==Authentication in ASP.NET Core is provided by **AuthenticationMiddleware** and a number of authentication services. These services are responsible for setting the current principal when a user logs in, saving it to a cookie, and loading the principal from the cookie on subsequent requests.
• The **AuthenticationMiddleware** is added by calling **UseAuthentication**() in your middleware pipeline. This must be placed after the call to UseRouting() and before UseAuthorization() and UseEndpoints().==
• ASP.NET Core includes support for consuming bearer tokens for authenticating API calls and includes helper libraries for configuring IdentityServer. For more details see https://docs.microsoft.com/aspnet/core/security/authentication/identity-apiauthorization.
• ASP.NET Core Identity handles low-level services needed for storing users in a database, ensuring their passwords are stored safely, and for logging users in and out. You must provide the UI for the functionality yourself and wire it up to the Identity subsystem.
• The Microsoft.AspNetCore.Identity.UI package provides a default UI for the Identity system, and includes email confirmation, 2FA, and external login provider support. You need to do some additional configuration to enable these features.
• The default template for a Web Application with Individual Account Authentication uses ASP.NET Core Identity to store users in the database with EF Core. It includes all the boilerplate code required to wire the UI up to the Identity system.
• You can use the UserManager<T> class to create new user accounts, load them from the database, and change their passwords. SignInManager<T> is used to sign a user in and out, by assigning the principal for the request and by setting an authentication cookie. The default UI uses these classes for you to facilitate user registration and login.
• You can update an EF Core DbContext to support Identity by deriving from IdentityDbContext<TUser> where TUser is a class that derives from IdentityUser. 
• You can add additional claims to a user using the UserManager<TUser>.AddClaimAsync(TUser user, Claim claim) method. These claims are added to the HttpContext.User object when the user logs in to your app.
• Claims consist of a type and a value. Both values are strings. You can use standard values for types exposed on the ClaimTypes class, such as ClaimTypes .GivenName and ClaimTypes.FirstName, or you can use a custom string, such as "FullName".  

**<u>Authorization: Securing your web application:</u>**

Authentication is the process of determining who a user is. It’s distinct from authorization, the process of determining what a user can do. Authentication typically occurs before authorization.
• You can use the authorization services in any part of your application, but it’s typically applied using the AuthorizationMiddleware by calling UseAuthorization(). This should be placed after the calls to UseRouting() and UseAuthentication(), and before the call to UseEndpoints() for correct operation.
• You can protect Razor Pages and MVC actions by applying the [Authorize] attribute. The routing middleware records the presence of the attribute as metadata with the selected endpoint. The authorization middleware uses this metadata to determine how to authorize the request.
• The simplest form of authorization requires that a user is authenticated before executing an action. You can achieve this by applying the [Authorize] attribute to a Razor Page, action, controller, or globally. You can also apply attributes conventionally to a sub-set of Razor Pages.
• Claims-based authorization uses the current user’s claims to determine whether they’re authorized to execute an action. You define the claims needed to execute an action in a policy.
• Policies have a name and are configured in Startup.cs as part of the call to AddAuthorization() in ConfigureServices. You define the policy using AddPolicy(), passing in a name and a lambda that defines the claims needed.
• You can apply a policy to an action or Razor Page by specifying the policy in the authorize attribute, for example [Authorize("CanAccessLounge")]. This policy will be used by the AuthorizationMiddleware to determine if the user is allowed to execute the selected endpoint.
• In a Razor Pages app, if an unauthenticated user attempts to execute a protected action, they’ll be redirected to the login page for your app. If they’re already authenticated, but don’t have the required claims, they’ll be shown an Access Denied page instead.
• For complex authorization policies, you can build a custom policy. A custom policy consists of one or more requirements, and a requirement can have one or more handlers. You can combine requirements and handlers to create policies of arbitrary complexity.
• For a policy to be authorized, every requirement must be satisfied. For a requirement to be satisfied, one or more of the associated handlers must indicate success, and none must indicate explicit failure.
• AuthorizationHandler<T> contains the logic that determines whether a requirement is satisfied. For example, if a requirement requires that users be over 18, the handler could look for a DateOfBirth claim and calculate the user’s age.
• Handlers can mark a requirement as satisfied by calling context.Succeed(requirement). If a handler can’t satisfy the requirement, then it
shouldn’t call anything on the context, as a different handler could call Succeed() and satisfy the requirement.
• If a handler calls context.Fail(), then the requirement will fail, even if a different handler marked it as a success using Succeed(). Only use this method if you want to override any calls to Succeed() from other handlers, to ensure the authorization policy will fail authorization.
• Resource-based authorization uses details of the resource being protected to determine whether the current user is authorized. For example, if a user is only allowed to edit their own documents, then you need to know the author of the document before you can determine whether they’re authorized.
• Resource-based authorization uses the same policy, requirements, and handler system as before. Instead of applying authorization with the [Authorize] attribute, you must manually call IAuthorizationService and provide the resource you’re protecting.
• You can modify the user interface to account for user authorization by adding additional properties to your PageModel. If a user isn’t authorized to execute an action, you can remove or disable the link to that action method in the UI. You should always authorize on the server, even if you’ve removed links from the UI.  