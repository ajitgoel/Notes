**<u>Improving your application's security:</u>**

****

==**<u>Cross-site scripting (XSS)</u>** attacks involve malicious users injecting content into your app, typically to run malicious JavaScript when users browse your app. You can avoid XSS injection attacks by always encoding unsafe input before writing it to a page. Razor Pages do this automatically== unless you use the @Html.Raw() method, so use it sparingly and carefully.
• ==**<u>Cross-site request forgery (CSRF)</u>** attacks are a problem for apps that use cookie-based authentication, such as ASP.NET Core Identity. It relies on the fact that browsers automatically send cookies to a website. A malicious website could create a form that POSTs to your API, and the browser will send the authentication cookie with the request. This allows malicious websites to send requests as though they’re the loggedin user.
• You can mitigate CSRF attacks using **<u>anti-forgery tokens</u>**. These involve writing a hidden field in every form that contains a random string based on the current user. A similar token is stored in a cookie. A legitimate request will have both parts, but a forged request from a malicious website will only have the cookie half; they cannot recreate the hidden field in the form. By validating these tokens, your API can reject forged requests.
• The Razor Pages framework automatically adds anti-forgery tokens to any forms you create using Razor and validates the tokens for inbound requests.== You can disable the validation check if necessary, using the [IgnoreAntiForgeryToken] attribute. 
• ==Browsers won’t allow websites to make JavaScript AJAX requests from one app to others at different origins. To match the origin, the app must have the same scheme, domain, and port. If you wish to make cross-origin requests like this, you must enable **<u>cross-origin resource sharing (CORS)</u>** in your API.==
• CORS uses HTTP headers to communicate with browsers and defines which origins can call your API. In ASP.NET Core, you can define multiple policies, which can be applied either globally to your whole app, or to specific controllers and actions.
• You can add the CORS middleware by calling UseCors() in Startup.Configure and optionally providing the name of the default CORS policy to apply. You can also apply CORS to a Web API action or controller by adding the [EnableCors] attribute and providing the name of the policy to apply.
• ==**<u>Open redirect attacks</u>** use the common returnURL mechanism after logging in to redirect users to malicious websites. You can prevent this attack by ensuring you only redirect to local URLs, URLs that belong to your app.
• **<u>Insecure direct object references</u>** are a common problem where you expose the ID of database entities in the URL. You should always verify that users have permission to access or change the requested resource by using resource-based authorization in your action methods.
• **<u>SQL injection attacks</u>** are a common attack vector when you build SQL requests manually. Always use parameterized queries when building requests, or instead use a framework like EF Core, which isn’t vulnerable to SQL injection.==
• The most sensitive data in your app is often the data of your users. Mitigate this risk by only storing data that you need. Ensure you only store passwords as a hash, protect against weak or compromised passwords, and provide the option for 2FA. ASP.NET Core Identity provides all of this out of the box, so it’s a great choice if you need to create an identity provider  

**<u>Authentication: Adding users to your application with Identity:</u>**

==Authentication is the process of determining who you are and authorization is the process of determining what you’re allowed to do. You need to authenticate users before you can apply authorization.
• Every request in ASP.NET Core is associated with a user, also known as a principal. By default, without authentication, this is an anonymous user. You can use the claims principal to behave differently depending on who made a request.
• The current principal for a request is exposed on HttpContext.User. You can access this value from your Razor Pages and views to find out properties of the user such as their, ID, Name or Email.
• Every user has a collection of claims. These claims are single pieces of information about the user. Claims could be properties of the physical user, such as Name and Email, or they could be related to things the user has, such as HasAdminAccess or IsVipCustomer.==
• Earlier versions of ASP.NET used roles instead of claims. You can still use roles if you need to, but you should use claims where possible.
• ==Authentication in ASP.NET Core is provided by AuthenticationMiddleware and a number of authentication services. These services are responsible for setting the current principal when a user logs in, saving it to a cookie, and loading the principal from the cookie on subsequent requests.
• The AuthenticationMiddleware is added by calling UseAuthentication() in your middleware pipeline. This must be placed after the call to UseRouting() and before UseAuthorization() and UseEndpoints().==
• ASP.NET Core includes support for consuming bearer tokens for authenticating API calls and includes helper libraries for configuring IdentityServer. For more details see https://docs.microsoft.com/aspnet/core/security/authentication/identity-apiauthorization.
• ASP.NET Core Identity handles low-level services needed for storing users in a database, ensuring their passwords are stored safely, and for logging users in and out. You must provide the UI for the functionality yourself and wire it up to the Identity subsystem.
• The Microsoft.AspNetCore.Identity.UI package provides a default UI for the Identity system, and includes email confirmation, 2FA, and external login provider support. You need to do some additional configuration to enable these features.
• The default template for a Web Application with Individual Account Authentication uses ASP.NET Core Identity to store users in the database with EF Core. It includes all the boilerplate code required to wire the UI up to the Identity system.
• You can use the UserManager<T> class to create new user accounts, load them from the database, and change their passwords. SignInManager<T> is used to sign a user in and out, by assigning the principal for the request and by setting an authentication cookie. The default UI uses these classes for you to facilitate user registration and login.
• You can update an EF Core DbContext to support Identity by deriving from IdentityDbContext<TUser> where TUser is a class that derives from IdentityUser. 
• You can add additional claims to a user using the UserManager<TUser>.AddClaimAsync(TUser user, Claim claim) method. These claims are added to the HttpContext.User object when the user logs in to your app.
• Claims consist of a type and a value. Both values are strings. You can use standard values for types exposed on the ClaimTypes class, such as ClaimTypes .GivenName and ClaimTypes.FirstName, or you can use a custom string, such as "FullName".  

